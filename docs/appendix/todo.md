# To do

* Add a "tricks" section of the docs
    * Dynamic module lookup (sitewraper.py)
        * How sitewrapper works and what it's for
        * Importing a package from a filesystem path
        * The old `progfiguration_build.py` script, which could be called from CI and was also imported by path insite progfiguration_cli
          (since deprecated since lobotomy and moving to progfigbuild; see git history)
    * zipapp
    * Packages with just pyproject.toml
    * run() command which outputs to stderr/stdout and also captures them
    * Dynamic version trickery
    * Data files in the Python stdlib: json, csv, configfile, and even TOML in Python 3.11+, also TOML in recent pip and setuptools
      (h/t <https://til.simonwillison.net/python/pyproject>)
    * Ode to Python stdlib
        * Data files (per above)
        * unittest module is good enough to start with
        * When do we allow dependencies?
          When it's best practice, and supported by well regarded orgs, like requests and setuptools.
          We are more tolerant of dev- and build- time dependencies,
          but runtime dependencies are not permitted in progfiguration core for maximum flexibility.
          Progfigsite implementations can use dependencies whenever it makes sense for them.
    * Vendoring (implementation TBD)
    * Python string.template, including custom subclasses
        * Can you avoid a full featured templating dependency like jinja?
          I do miss conditionals, but...
    * ... all the other tricks I found to make this work
* Add a "lore" section of the docs
    * History:
        * Built for psyopsOS
        * Made more general
        * Lobotomized into core and progfigsite
* Make sure progfiguration core works on all in-support Python 3 verions
* Currently `progfiguration build pyz ...` copies the running progfiguration into the file.
  Consider adding support for downloading a fresh copy from pypi,
  in case the user does something weird with their current version.
* Let nodes set a Localhost class
* Before first release
  * Update example sites
    * Use example_site as an example, NNSS can hold more complicated test only stuff
    * Maybe make an example template site, and/or add that functionality to the commandline
    * Test the recent site version stuff with unit tests
  * Show example with support for at least one site specific package implementation, maybe RPM or just link to psyops progfigsite for APK
  * Get APK working so I can use this myself...
  * Test that pip packages are doing what I want. Do they have all functionality of old non-lobotomy?
  * Merge lobotomy.
  * Build a documentation site
* Make the inventory an API. Don't require a specific file, but require a class implementation.
  * Provide an easy to use configparser implementation
  * Note that alternatives could be in yaml or json or generated by some external program
* Can I make sphinx-autobuild faster? Waiting 5+ seconds on every single file save is _horrible_.
