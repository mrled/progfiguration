To do
=====

* Add a "tricks" section of the docs

    * Dynamic module lookup (sitewraper.py)

        * How sitewrapper works and what it's for
        * Importing a package from a filesystem path
        * The old `progfiguration_build.py` script, which could be called from CI and was also imported by path insite progfiguration_cli
          (since deprecated since lobotomy and moving to progfigbuild; see git history)

    * zipapp
    * Packages with just pyproject.toml
    * run() command which outputs to stderr/stdout and also captures them
    * Dynamic version trickery
    * Data files in the Python stdlib: json, csv, configfile, and even TOML in Python 3.11+, also TOML in recent pip and setuptools
      (h/t <https://til.simonwillison.net/python/pyproject>)
    * Ode to Python stdlib

        * Data files (per above)
        * unittest module is good enough to start with
        * When do we allow dependencies?
          When it's best practice, and supported by well regarded orgs, like requests and setuptools.
          We are more tolerant of dev- and build- time dependencies,
          but runtime dependencies are not permitted in progfiguration core for maximum flexibility.
          Progfigsite implementations can use dependencies whenever it makes sense for them.

    * Vendoring (implementation TBD)
    * Python string.template, including custom subclasses

        * Can you avoid a full featured templating dependency like jinja?
          I do miss conditionals, but...

    * ... all the other tricks I found to make this work

* Add a "lore" section of the docs

    * History:

        * Built for psyopsOS
        * Made more general
        * Lobotomized into core and progfigsite

* Make sure progfiguration core works on all in-support Python 3 verions
* Currently `progfiguration build pyz ...` copies the running progfiguration into the file.
  Consider adding support for downloading a fresh copy from pypi,
  in case the user does something weird with their current version.
* Let nodes set a Localhost class
* Move localhost stuff to a module, don't use a class. I don't think I get any benefits from it being a class. If it really needs to be one, consider a global singleton if I can. Making you instantiate `Localhost()` in multiple places is silly.
* Before first release

  * Update example sites

    * Use example_site as an example, NNSS can hold more complicated test only stuff
    * Maybe make an example template site, and/or add that functionality to the commandline
    * Test the recent site version stuff with unit tests

  * **make a first release**

* Make the inventory an API. Don't require a specific file, but require a class implementation.

  * Provide an easy to use configparser implementation
  * Note that alternatives could be in yaml or json or generated by some external program

* Can I make sphinx-autobuild faster? Waiting 5+ seconds on every single file save is _horrible_.
* Add a philosophy section, or include all of this in the design section:

  * The Python stdlib is one of its strengths, how can we stay within it as much as possible

    * Reference the section in "tricks", or just m ove that stuff here

  * Imperative vs declarative

    * Strengths of declarative:

      * easy things are easy, organized
      * **easy to read**, especially for someone who hasn't seen your project before. this is a huge strength in a decentralized project, or a big company. Declarative stuff is a common language that everyone understands.

    * Strengths of imperative:

      * You're going to end up doing a bunch of imperative gunk anyway in your nice declarative language, why not embrace it
      * No one is going to pretend that for loops in Terraform are nicer than just, a Python for loop, right? We don't have to debate that I hope?

    * Makes sense to use each for their strengths.

      * I'd default to Cloudformation for Route53 entries
      * But if I were setting up a complex system of VPCs, EC2 instances, IAM roles, etc, I'd probably look to the AWS API before too very long. I've done 5-10 2k line cloudformation files to set up infrastructure.

    * Ansible, Terraform, Cloudformation all are easy to hire for
